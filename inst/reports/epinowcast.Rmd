---
title: Estimating reporting delays and nowcasting/forecasting infections with epinowcast
---

# Summary

In this report we will make use of `epinowcast` an in development nowcasting package designed from the ground up around nowcasting and aiming to replace `EpiNow2` for real-time usage. We first explore the data using tools from `epinowcast` alongside others. We then nowcast the latest available data, visualise our results, and discussion potential options for improving performance on real-world data. As a check of our approach we construct some retrospective data, nowcast it, and compare our nowcast to the latest available data. We then extract the estimated delay distribution and compare it to the underlying distribution used to generate the data, the empirical distribution, and the distribution estimated using simpler methods. Finally we show how the output from `epinowcast` may be used in other surveillance packages such as `EpiNow2`, discuss potential issues with this approach, and highlight areas for futher work. For more on `epinowcast` see [the package documentation](https://epiforecasts.io/epinowcast/).

# Load required libraries

```{r init}
suppressPackageStartupMessages(library("epinowcast"))
suppressPackageStartupMessages(library("EpiNow2"))
suppressPackageStartupMessages(library("nowcasting.example")) ## devtools::install()
suppressPackageStartupMessages(library("dplyr"))
suppressPackageStartupMessages(library("ggplot2"))
suppressPackageStartupMessages(library("rstan"))
suppressPackageStartupMessages(library("posterior"))
suppressPackageStartupMessages(library("tidyr"))
suppressPackageStartupMessages(library("fitdistrplus"))
suppressPackageStartupMessages(library("purrr"))
```
# Load the data

As in other reports in this repository this data is generated using `inst/scripts/create_mock_dataset.r`. The simulation model is based on real-world datasets and an underlying assumption that the reporting delay is parametric and follows a log-normal distribution with a logmean of 2 and a logsd of 0.5.

```{r load_data}
df <- load_data()
max_delay <- max(df$delay, na.rm = TRUE)
glimpse(df)
```

# Data exploration

```{r plot_data}
ggplot(df, aes(x = delay)) +
  geom_histogram(binwidth = 1) +
  theme_bw()
```

There are negative delays (report before onset) - possibly representing either data entry errors or positive tests during the incubation period so hard to characterise as part of the reporting delay distribution.

```{r negative_delays}
df |>
  filter(delay < 0)
```

There is also a significant excess at delay 0, which does not connect smoothly to the rest of the distribution and therefore seems to represent a separate process.

# Preprocessing and visualising the data

Before we can estimate the reporting delay for onsets or nowcast unreporteed onsets we need to preprocess the data into a format `epinowcast` can make use of. We first need to restrict to delays greater than 0 due to the evidence for two reporting processes and aggregate data into the cumulative count format `epinowcast` expects. Note that `epinowcast` defines the target date (here the onset date) as the `reference_date`.

```{r preprocess}
count_df <- df |>
  filter(delay > 0 | is.na(delay)) |>
  rename(reference_date = date_onset) |>
  count(reference_date, report_date, name = "confirm") |>
  arrange(reference_date, report_date) |>
  group_by(reference_date) |>
  mutate(cum_confirm = cumsum(confirm)) |>
  ungroup() |>
  mutate(confirm = ifelse(!is.na(reference_date), cum_confirm, confirm)) |>
  dplyr::select(-cum_confirm)
glimpse(count_df)
```

We can now use preprocessing functions from `epinowcast` to complete all combinations of report and reference dates, prepare for modelling, and produce a range of useful summary datasets. Note that `epinowcast` returns output as `data.table` but users can make use of whatever data manipulation tools they are most comformfortable with. We first make sure all date combinations are present and then use a wrapper, `enw_preprocess_data()` to complete the rest of the required preprocessing steps. We set the maximum delay using the largest observed delay, though users should consider this with care as large outliers may impact this significantly.

```{r epinowcast-preprocess}
complete_df <- count_df |>
  enw_complete_dates(max_delay = max_delay + 5)
glimpse(complete_df)

enw_df <- complete_df |>
  enw_preprocess_data(max_delay = max_delay + 5)
enw_df
```

Our output contains several useful measures including the maximum date of data, the maximum delay, the number of days included in the dataset, and the number of groups (here only one but this feature allows us to nowcast over stratifications such as age or location or a combination).

To start with we may want to plot the latest available data alongside some previous updates (blue bars increasingly pale as it gets newer) and the data by date of report (grey bars)

```{r latest-data}
complete_df |>
  filter(
    report_date %in% as.Date(c("2020-03-15", "2020-04-01", "2020-04-15")) |
    report_date == max(report_date)
  ) |>
  mutate(report_date = factor(report_date) |>
    forcats::fct_rev()
  ) |>
  ggplot() +
  aes(
    x = reference_date, y = confirm, fill = report_date, group = report_date
  ) +
  geom_col(
    data = enw_df$new_confirm[[1]] |>
      group_by(report_date) |>
      summarise(confirm = sum(new_confirm)),
    fill = "lightgrey", alpha = 0.8,
    aes(x = report_date)
  ) +
  geom_col(position = "identity", alpha = 0.7, col = "lightgrey") +
  geom_vline(
    aes(xintercept = as.Date(report_date)), linetype = 2, alpha = 0.9
  ) +
  scale_y_continuous(labels = ~ scales::comma(.x, accuracy = 1)) +
  scale_fill_brewer(palette = "Blues") +
  theme_bw() +
  labs(
    x = "Date of onset", y = "Reported cases with onset", fill = "Report date"
  ) +
  theme(legend.position = "bottom")
```
In this example the number/proportion of cases missing onsets may be of particular interest (note modelling of this data is currently in development for `epinowcast`).

```{r missing-data}
enw_df$missing_reference[[1]] |>
  as_tibble() |>
  filter(report_date >= "2020-03-11") |>
  ggplot() +
  aes(x = report_date, y = prop_missing) +
  geom_col(fill = "lightblue") +
  scale_y_continuous(labels = scales::percent) +
  theme_bw() +
  labs(x = "Report date of onsets", y = "Proportion of cases missing onsets")
```

# Nowcasting

`epinowcast` implements a generic and extended form of one of the most common nowcasting approaches. This involves decomposing the task into two sub-models. An expectation model that captures the evolution of the underlying count data (here by default a daily random walk on the log scale) and a reporting model specified using the discrete hazard of a case being reported after a given number of days. More on the methodology of this implementation and its links to previous literature can be found [here](https://epiforecasts.io/epinowcast/). 


We use a simple model that assumes a Poisson observation process and a parametric log-normal reporting distribution. As a first step, we need to compile the `epinowcast` model, we do this with `threads = TRUE` in order to support multi-threading to speed up estimation. We also define our fitting options (note these are passed to `cmdstanr` which is the backend tool we use for model fitting).

```{r fit-opts}
model <- enw_model(threads = TRUE)

fit_opts <- enw_fit_opts(
    chains = 2, parallel_chains = 2, threads_per_chain = 2,
    iter_sampling = 1000, iter_warmup = 1000,
    show_messages = FALSE, pp = TRUE
)
```

We can then fit our nowcasting model. If interested in what each component is doing the output can be inspected interactively (for example the output of `enw_obs(family = "poisson", data = enw_df)` is data preprocessed into the format required for modelling).

```{r simple-epinowcast}
simple_nowcast <- epinowcast(
  obs = enw_obs(family = "poisson", data = enw_df),
  data = enw_df, model = model, fit = fit_opts,
)
```

The first thing we might want to do is look at the summarised nowcast for the last week.

```{r summarised-simple-nowcast}
simple_nowcast |>
  summary(probs = c(0.05, 0.95)) |>
  tail(n = 7)
```

We can also plot this nowcast against the latest data.

```{r plot-simple-nowcast}
simple_nowcast |>
  plot() +
  labs(x = "Onset date", y = "Reported cases by onset date")
```

In order to inspect how our model is doing we might also want to plot observations against posterior predictions summarised by the delay from onset to report. Here columns are the observed data. The dashed line is the median of summarised predictions and the ribbons are the 60% and 80% scredible intervals. Note these are estimated by adding individual prediction quantiles and so likely over estimate uncertainty.

```{r plot-posterior-predictions}
summary(simple_nowcast, type = "posterior_prediction") |>
  group_by(delay) |>
  summarise(
    across(c(new_confirm, median, q5, q20, q80, q95), ~ sum(.x)),
    .groups = "drop"
  ) |>
  ggplot() +
  aes(x = delay, y = new_confirm) +
  geom_col(col = "#d3d3d393") +
  geom_line(aes(y = median), size = 1.5, linetype = 2, col = "lightblue") +
  geom_ribbon(aes(ymin = q5, ymax = q95), alpha = 0.3, fill = "lightblue") +
  geom_ribbon(aes(ymin = q20, ymax = q80), alpha = 0.3, fill = "lightblue") +
  theme_bw() +
  labs(x = "Days since onset", y = "Reported cases with onset")
```

Finally, we can also look at the posterior estimates for the parametric delay distribution (remembering that a logmean of 2 and a logsd of 0.5 was used to generate the simulated data). Here `refp_mean` denotes the logmean and `refp_sd` denotes the log standard deviation. We see our estimates are close to those from the data generating process though don't cover them at the 90% credible interval. This may be driven by bias in the generating process, (as 0 delays are excluded), by our use of a truncated distribution truncated by the maximum delay, inherent loss/lack of information, or from our inference technique.

```{r}
simple_nowcast |>
  summary(type = "fit", variables = c("refp_mean", "refp_sd"))
```

In real-world data we might expect to see delays drawn from different distributions or no apparent distribution, time-varying delays in reporting, overdispersed reporting, and the likelihood of reporting varying by report date (i.e due to the day of the week etc.). All of these complexities can be modelled using `epinowcast 0.1.0`.

As we saw in our data we also have negative delays, overinflated counts with zero delays, reported cases missing onsets and a clear day of the week effect in the underlying simulated data. Modelling all of these features, rather than exluding them or ignoring them, would likely reduce bias. These features, exluding negative delays, are on the roadmap for `epinowcast 0.2.0` please reach out if they would be of use to you. Negative delays are potentially the most complex modelling issue as they are technically not possible if we define a reporting date to be later than or equal to the reference date, which is how many nowcasting models work. We instead need to a generative process that leads to both of these observations. Doing this is planned for a future version of `epinowcast` but not currently in the roadmap again reach out if this is key to your use case.

# Retrospective evaluation

In order to understand how well our nowcasting method is working in real-time it can be useful to have an understanding on how well it did on past data that is know up to date, or more up to date. Here we conduct another nowcast, in the same way as above but on a reconstructed version of what we think the data available on the 1st of April 2020 would have looked like. The first step is to construct this retrospective data and to extract what the latest data looks like for this time period.

```{r make-retro-df}
retro_df <- complete_df |>
 enw_filter_report_dates(latest_date = "2020-04-01")

latest_retro_obs <- complete_df |>
  enw_latest_data()
tail(latest_retro_obs, n = 5)
```

We can now preprocess the data as before and fit the same nowcasting model.

```{r retro_nowcast}
retro_nowcast <- retro_df |>
  enw_preprocess_data(max_delay = max_delay) |>
  (\(x) epinowcast(
    obs = enw_obs(family = "negbin", data = x),
    data = x, model = model, fit = fit_opts,
  ))()
```

We now plot this retrospective nowcast against the latest available data (noting that some of the more recently reported data may not be fully complete yet). Here we see our approach is doing relatively well at capturing the lastest available obserservations (triangles) using the data available at the time (circles) though perhaps is a little more uncertain than we might ideally like.

```{r plot-retro-nowcast}
plot(retro_nowcast, latest_retro_obs) +
  labs(x = "Onset date", y = "Reported cases by onset date")
```

# Comparison to simpler approaches

As for our `EpiNow2` comparison here we compare the etimated delay distribution from epinowcast with empirical estimates, estimates from simpler methods, and the known distribution used when simulating the data.

## Empirical delay

```{r empirical}
positive_df <- df |>
  filter(delay > 0)

x <- 1:26
emp <- ecdf(positive_df$delay)
emp_cdf <- data.frame(
  delay = x,
  cdf = emp(x),
  Method = "Empirical"
)
```

## Discretised lognormal fitted directly

```{r dislnorm}
ddislnorm <- function(x, meanlog, sdlog) {
  return(plnorm(x, meanlog, sdlog) - plnorm(x - 1, meanlog, sdlog))
}
pdislnorm <- plnorm
qdislnorm <- qlnorm

y <- fitdist(
  positive_df$delay,
  "dislnorm",
  start = list(meanlog = 0, sdlog = 1)
)
ln <- pdislnorm(1:26, y$estimate[1], y$estimate[2])
ln_cdf <- data.frame(delay = x, cdf = ln, Method = "Direct")
```

## Extract the lognormal CMF from `epinowcast`

```{r}
extract_epinowcast_cmf <- function(nowcast) {
  nowcast |>
  (\(x) x$fit[[1]]$draws(variables = c("refp_mean", "refp_sd")))() |>
  as_draws_df() |>
  mutate(pmf = purrr::map2(
    `refp_mean[1]`, `refp_sd[1]`,
    ~ data.frame(
      delay = 1:26, pmf = pdislnorm(1:26, .x, .y)
    ))
  ) |>
  unnest(pmf) |>
  group_by(delay) |>
  summarise(
    pmf = mean(pmf), lower_90 = quantile(pmf, 0.05),
    upper_90 = quantile(pmf, 0.95)
  )
}

epinowcast_cdf <- list(
  "epinowcast (real-time)" = simple_nowcast,
  "epinowcast (retrospective)" = retro_nowcast
) |>
  map_df(extract_epinowcast_cmf, .id = "Method")
```

## Comparison

```{r compare}
true_cdf <- data.frame(
  delay = 1:26, pmf = pdislnorm(1:26, 2, 0.5), method = "Data generating"
)

combined <- bind_rows(
  true_cdf,
  emp_cdf,
  ln_cdf,
  epinowcast_cdf
)

ggplot(combined, aes(x = delay, y = cdf, linetype = Method)) +
  geom_line() +
  geom_ribbon(
    mapping = aes(ymin = lower_90, ymax = upper_90),
    alpha = 0.25
  ) +
  theme_bw()
```

# Nowcast

```{r estimate_infections, eval = FALSE}
## create a data set of reported cases
## (would be better to use onsets but missing data are an issue)
reported_cases <- df |>
  count(report_date, name = "confirm") |>
  rename(date = report_date)

## generation interval
## from: https://www.gov.uk/government/publications/monkeypox-outbreak-technical-briefings/investigation-into-monkeypox-outbreak-in-england-technical-briefing-1
## Preliminary estimate of the serial interval is 9.8 days though with high uncertainty (95% credible interval, 5.9 to 21.4).
## It is unclear whether this refers to the estimate of the mean, or the spread of serial intervals
## It is also unclear whether this is growth-adjusted
## interpreted as log-normally distributed with 95% contained between 5.9 and 21.4:
## => \mu*/\sigma*^2 = 5.9; \mu* * \sigma*^2 = 21.4
## => \mu* = 11,  \sigma* = 1.4
## (see https://en.wikipedia.org/wiki/Log-normal_distribution#Scatter_intervals)
generation_interval <- list(
  mean = log(11),
  mean_sd = 0,
  sd = log(1.4),
  sd_sd = 0,
  max = 25
)

## incubation period
## from: https://www.who.int/news-room/fact-sheets/detail/monkeypox
## "usually from 6 to 13 days but can range from 5 to 21"
## interpreted as log-normally distributed with 2/3 contained between 6 and 13:
## => \mu*/\sigma* = 6; \mu^* * \sigma* = 13
## => \mu* = 9, \sigma* = 1.5,  max = 21
## (see https://en.wikipedia.org/wiki/Log-normal_distribution#Scatter_intervals)
## also adding a small amount of uncertainty
incubation_period <- list(
  mean = log(9),
  mean_sd = 0.1,
  sd = log(1.5),
  sd_sd = 0.1,
  max = 21
)

delays <- delay_opts(
  ## incubation period
  incubation_period,
  ## reporting delay
  est$dist
)

inf <- estimate_infections(
  reported_cases = reported_cases,
  generation_time = generation_interval,
  delays = delays,
  verbose = FALSE
)

plot(inf)
```
